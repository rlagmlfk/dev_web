전제조건
반드시 메소드 이름은 같아야 한다.
메소드 이름이 다르면 메소드 오버로딩 또는 오버라이딩에 관해 따지지 않음
단 메소드 오버라이딩의 경우에는 반드시 상속관계에 있거나 인터페이스의 구현체 클래스 이어야 한다.
생성자도 메소드 오버로딩의 규칙을 적용받는다.

메소드 오버로딩
반드시 파라미터의 갯수가 다르거나, 파라미터의 타입이 달라야 한다.
리턴타입이 있고 없고는 영향이 없다.
접근제한자가 있고 없고는 영향이 없다.
파라미터의 변수명이 다른 것도 영향이 없다.
예외처리가 있고 없고도 영향이 없다.

메소드 오버라이딩
반드시 선언부가 일치해야 한다.
리턴타입을 바꾸면 안된다.
접근제한자의 경우 더 넓은 것은 올 수 있지만, 더 좁은 접근제한자는 불가하다.
public > protected > friendly > private

protected: 서로 다른 패키지 이더라도 서로 상속관계에 있다면 접근가능하다.
friendly: 같은 패키지에서만 접근 가능함.

객체지향적 프로그래밍 기법 -> 함수형 프로그래밍 기법


2022.5.6(금)

modifier - 수정자

접근제한자 - access modifier
public(+) > protected(#) > friendly 상태 > private

그 외 제한자 - etc
static - 위치: 변수 앞 -> 전역변수이면서 인스턴스화 없이도 호출 가능
                 메소드 앞 -> 인스턴스화 없이도 호출 가능
                 클래스 앞 -> 하나다(여러 개를 복제하지 않는다)


final: 변수 앞 -> 상수
       메소드 앞 -> 오버라이딩이 안 된다.
       클래스 앞 -> 자녀클래스를 가질 수 없다.


메소드 선언시 리턴타입을 결정할 수 있니?
파라미터 갯수와 타입까지도 선택할 수 있니?

----------------------------------------------------------------------------------------------------

회차를 관리한다.

int cnt;

cnt = 0;

cnt = 1;

두 번째: 전역변수 or 지역변수?

언제 반복문을 탈출할 것인가?

위치의 문제와 연결되어 있다. 의존관계에 있다. -> 결합도가 높다. 

언제까지 유지해야 되는가?

현재 클래스(전역변수)에서만 유지되면 되나? 아니면 다른 클래스에서도 유지되어야 하나? - static(공유)

기회1

기회2

기회3

기회4

기회5
